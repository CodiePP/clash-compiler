[ { "BlackBox" :
    { "name"      : "GHC.Prim.gtChar#"
    , "type"      : "gtChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geChar#"
    , "type"      : "geChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqChar#"
    , "type"      : "eqChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neChar#"
    , "type"      : "neChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltChar#"
    , "type"      : "ltChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leChar#"
    , "type"      : "leChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ord#"
    , "type"      : "ord# :: Char# -> Int#"
    , "templateE" : "signed(std_logic_vector(resize(~ARG[0],~SIZE[~TYPO])))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.+#"
    , "type"      : "(+#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.-#"
    , "type"      : "(-#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.*#"
    , "type"      : "(*#) :: Int# -> Int# -> Int#"
    , "templateE" : "resize(~ARG[0] * ~ARG[1],~SIZE[~TYPO])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotInt#"
    , "type"      : "quotInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remInt#"
    , "type"      : "remInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] rem ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemInt#"
    , "type"      : "quotRemInt# :: Int# -> Int# -> (#Int#, Int##)"
    , "templateE" : "(~ARG[0] / ~ARG[1], ~ARG[0] rem ~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.andI#"
    , "type"      : "and# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] and ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.orI#"
    , "type"      : "or# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] or ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xorI#"
    , "type"      : "xor# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] xor ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.notI#"
    , "type"      : "not# :: Int# -> Int#"
    , "templateE" : "not ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.negateInt#"
    , "type"      : "negateInt# :: Int# -> Int#"
    , "templateE" : "-~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>#"
    , "type"      : "(>#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>=#"
    , "type"      : "(>=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.==#"
    , "type"      : "(==) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim./=#"
    , "type"      : "(/=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<#"
    , "type"      : "(<#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<=#"
    , "type"      : "(<=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.chr#"
    , "type"      : "ord# :: Int# -> Chr#"
    , "templateE" : "resize(unsigned(std_logic_vector(~ARG[0])),21)"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.int2Word#"
    , "type"      : "word2Int# :: Int# -> Word#"
    , "templateE" : "unsigned(std_logic_vector(~ARG[0]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftL#"
    , "type"      : "uncheckedIShiftL# :: Int# -> Int# -> Int#"
    , "templateE" : "shift_left(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRA#"
    , "type"      : "uncheckedIShiftRA# :: Int# -> Int# -> Int#"
    , "templateE" : "shift_right(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRL#"
    , "type"      : "uncheckedIShiftRL# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] srl to_integer(~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.plusWord#"
    , "type"      : "plusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.minusWord#"
    , "type"      : "minusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.timesWord#"
    , "type"      : "timesWord# :: Word# -> Word# -> Word#"
    , "templateE" : "resize(~ARG[0] * ~ARG[1],~SIZE[~TYPO])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotWord#"
    , "type"      : "quotWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remWord#"
    , "type"      : "remWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] rem ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemWord#"
    , "type"      : "quotRemWord# :: Word# -> Word# -> (#Word#, Word##)"
    , "templateE" : "(~ARG[0] / ~ARG[1], ~ARG[0] rem ~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.and#"
    , "type"      : "and# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] and ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.or#"
    , "type"      : "or# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] or ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xor#"
    , "type"      : "xor# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] xor ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.not#"
    , "type"      : "not# :: Word# -> Word#"
    , "templateE" : "not ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedShiftL#"
    , "type"      : "uncheckedShiftL# :: Word# -> Int# -> Word#"
    , "templateE" : "shift_left(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedShiftRL#"
    , "type"      : "uncheckedShiftR# :: Word# -> Int# -> Word#"
    , "templateE" : "shift_right(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.word2Int#"
    , "type"      : "word2Int# :: word# -> Int#"
    , "templateE" : "signed(std_logic_vector(~ARG[0]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.gtWord#"
    , "type"      : "gtWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geWord#"
    , "type"      : "geWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqWord#"
    , "type"      : "eqWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neWord#"
    , "type"      : "neWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltWord#"
    , "type"      : "ltWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leWord#"
    , "type"      : "leWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt8#"
    , "type"      : "popCnt8 :: Word# -> Word#"
    , "templateD" :
"-- popCnt8 begin
popCnt8_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 8;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt16#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt16 begin
popCnt16_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 16;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt32#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt32 begin
popCnt32_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 32;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt64#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt64 begin
popCnt64_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 64;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt begin
popCnt_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := ~SIZE[~TYPO];
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Int#"
    , "type"      : "narrow8Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow8Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](7 downto 0),~SIZE[~TYPO]);
end block;
-- narrow8Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Int#"
    , "type"      : "narrow16Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow16Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](15 downto 0),~SIZE[~TYPO]);
end block;
-- narrow16Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Int#"
    , "type"      : "narrow32Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow32Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](31 downto 0),~SIZE[~TYPO]);
end block;
-- narrow32Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Word#"
    , "type"      : "narrow8Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow8Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](7 downto 0),~SIZE[~TYPO]);
end block;
-- narrow8Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Word#"
    , "type"      : "narrow16Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow16Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](15 downto 0),~SIZE[~TYPO]);
end block;
-- narrow16Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Word#"
    , "type"      : "narrow32Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow32Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](31 downto 0),~SIZE[~TYPO]);
end block;
-- narrow32Word end"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.dataToTag#"
    , "primType" : "Function"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.tagToEnum#"
    , "primType" : "Function"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.unsafeCoerce#"
    , "type"      : "unsafeCoerce# :: a -> b"
    , "templateE" : "~ARG[0]"
    }
  }
]
