[ { "BlackBox" :
    { "name"      : "GHC.Prim.gtChar#"
    , "type"      : "gtChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geChar#"
    , "type"      : "geChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqChar#"
    , "type"      : "eqChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neChar#"
    , "type"      : "neChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltChar#"
    , "type"      : "ltChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leChar#"
    , "type"      : "leChar# :: Char# -> Char# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ord#"
    , "type"      : "ord# :: Char# -> Int#"
    , "templateE" : "signed(std_logic_vector(resize(~ARG[0],~SIZE[~TYPO])))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.+#"
    , "type"      : "(+#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.-#"
    , "type"      : "(-#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.*#"
    , "type"      : "(*#) :: Int# -> Int# -> Int#"
    , "templateE" : "resize(~ARG[0] * ~ARG[1],~SIZE[~TYPO])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotInt#"
    , "type"      : "quotInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remInt#"
    , "type"      : "remInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] rem ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemInt#"
    , "type"      : "quotRemInt# :: Int# -> Int# -> (#Int#, Int##)"
    , "templateE" : "(~ARG[0] / ~ARG[1], ~ARG[0] rem ~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.andI#"
    , "type"      : "and# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] and ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.orI#"
    , "type"      : "or# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] or ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xorI#"
    , "type"      : "xor# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] xor ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.notI#"
    , "type"      : "not# :: Int# -> Int#"
    , "templateE" : "not ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.negateInt#"
    , "type"      : "negateInt# :: Int# -> Int#"
    , "templateE" : "-~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>#"
    , "type"      : "(>#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>=#"
    , "type"      : "(>=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.==#"
    , "type"      : "(==) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim./=#"
    , "type"      : "(/=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<#"
    , "type"      : "(<#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<=#"
    , "type"      : "(<=#) :: Int# -> Int# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.chr#"
    , "type"      : "ord# :: Int# -> Chr#"
    , "templateE" : "resize(unsigned(std_logic_vector(~ARG[0])),21)"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.int2Word#"
    , "type"      : "word2Int# :: Int# -> Word#"
    , "templateE" : "unsigned(std_logic_vector(~ARG[0]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftL#"
    , "type"      : "uncheckedIShiftL# :: Int# -> Int# -> Int#"
    , "templateE" : "shift_left(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRA#"
    , "type"      : "uncheckedIShiftRA# :: Int# -> Int# -> Int#"
    , "templateE" : "shift_right(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRL#"
    , "type"      : "uncheckedIShiftRL# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] srl to_integer(~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.plusWord#"
    , "type"      : "plusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.minusWord#"
    , "type"      : "minusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.timesWord#"
    , "type"      : "timesWord# :: Word# -> Word# -> Word#"
    , "templateE" : "resize(~ARG[0] * ~ARG[1],~SIZE[~TYPO])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotWord#"
    , "type"      : "quotWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remWord#"
    , "type"      : "remWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] rem ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemWord#"
    , "type"      : "quotRemWord# :: Word# -> Word# -> (#Word#, Word##)"
    , "templateE" : "(~ARG[0] / ~ARG[1], ~ARG[0] rem ~ARG[1])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.and#"
    , "type"      : "and# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] and ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.or#"
    , "type"      : "or# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] or ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xor#"
    , "type"      : "xor# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] xor ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.not#"
    , "type"      : "not# :: Word# -> Word#"
    , "templateE" : "not ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedShiftL#"
    , "type"      : "uncheckedShiftL# :: Word# -> Int# -> Word#"
    , "templateE" : "shift_left(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedShiftRL#"
    , "type"      : "uncheckedShiftR# :: Word# -> Int# -> Word#"
    , "templateE" : "shift_right(~ARG[0],to_integer(~ARG[1]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.word2Int#"
    , "type"      : "word2Int# :: word# -> Int#"
    , "templateE" : "signed(std_logic_vector(~ARG[0]))"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.gtWord#"
    , "type"      : "gtWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] > ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geWord#"
    , "type"      : "geWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] >= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqWord#"
    , "type"      : "eqWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] = ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neWord#"
    , "type"      : "neWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] /= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltWord#"
    , "type"      : "ltWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] < ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leWord#"
    , "type"      : "leWord# :: Word# -> Word# -> Int#"
    , "templateD" : "~RESULT <= to_signed(1,~SIZE[~TYPO]) when ~ARG[0] <= ~ARG[1] else to_signed(0,~SIZE[~TYPO]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt8#"
    , "type"      : "popCnt8 :: Word# -> Word#"
    , "templateD" :
"-- popCnt8 begin
popCnt8_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 8;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt16#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt16 begin
popCnt16_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 16;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt32#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt32 begin
popCnt32_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 32;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt64#"
    , "type"      : "popCnt16 :: Word# -> Word#"
    , "templateD" :
"-- popCnt64 begin
popCnt64_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := 64;
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt#"
    , "type"      : "popCnt :: Word# -> Word#"
    , "templateD" :
"-- popCnt begin
popCnt_~SYM[0] : block
  -- given a level and a depth, calculate the corresponding index into the
  -- intermediate array
  function depth2Index (levels,depth : in natural) return natural is
  begin
    return (2 ** levels - 2 ** depth);
  end function;

  constant width : natural := ~SIZE[~TYPO];
  constant levels : natural := natural (ceil (log2 (real (width))));
  type popCnt_res_vec is array (natural range <>) of unsigned(levels downto 0);
  signal intermediate_~SYM[1] : popCnt_res_vec(0 to (2*width)-2);
begin
  -- put input into the first half of the intermediate array
  make_array: for i in 0 to (width - 1) generate
    intermediate_~SYM[1](i) <= resize(~ARG[0](i downto i),levels+1);
  end generate;

  -- Create the tree of adders
  make_tree : if levels /= 0 generate
    tree_depth : for d in levels-1 downto 0 generate
      tree_depth_loop: for i in 0 to (natural(2**d) - 1) generate
        intermediate_~SYM[1](depth2Index(levels+1,d+1)+i) <=
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)) +
          intermediate_~SYM[1](depth2Index(levels+1,d+2)+(2*i)+1);
      end generate;
    end generate;
  end generate;

  -- The last element of the intermediate array holds the result
  ~RESULT <= resize(intermediate_~SYM[1]((2*width)-2),~SIZE[~TYPO]);
end block;
-- popCnt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz8#"
    , "type"      : "clz8 :: Word# -> Word#"
    , "templateD" :
"-- clz8 begin
clz8~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz8 (constant v : unsigned(0 to 7)) return unsigned is
    variable e : unsigned(0 to 7);     -- 8
    variable a : unsigned(0 to 2*3-1); -- 6
  begin
    for i in 0 to 3 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 1 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    return clzi(3,a(0 to 5));
  end function;
begin
  ~RESULT <= resize(clz8(~ARG[0](7 downto 0)),~SIZE[~TYPO]);
end block;
-- clz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz16#"
    , "type"      : "clz16 :: Word# -> Word#"
    , "templateD" :
"-- clz16 begin
clz16~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz16 (constant v : unsigned(0 to 15)) return unsigned is
    variable e : unsigned(0 to 15);    -- 16
    variable a : unsigned(0 to 4*3-1); -- 12
    variable b : unsigned(0 to 2*4-1); -- 8
  begin
    for i in 0 to 7 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 3 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    for i in 0 to 1 loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5)); end loop;
    return clzi(4,b(0 to 7));
  end function;
begin
  ~RESULT <= resize(clz16(~ARG[0](15 downto 0)),~SIZE[~TYPO]);
end block;
-- clz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz32#"
    , "type"      : "clz32 :: Word# -> Word#"
    , "templateD" :
"-- clz32 begin
clz32~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz32 (constant v : unsigned(0 to 31)) return unsigned is
    variable e : unsigned(0 to 31);    -- 32
    variable a : unsigned(0 to 8*3-1); -- 24
    variable b : unsigned(0 to 4*4-1); -- 16
    variable c : unsigned(0 to 2*5-1); -- 10
  begin
    for i in 0 to 15 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 7  loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    for i in 0 to 3  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5)); end loop;
    for i in 0 to 1  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7)); end loop;
    return clzi(5,c(0 to 9));
  end function;
begin
  ~RESULT <= resize(clz32(~ARG[0](31 downto 0)),~SIZE[~TYPO]);
end block;
-- clz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz64#"
    , "type"      : "clz64 :: Word# -> Word#"
    , "templateD" :
"-- clz64 begin
clz64~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz64 (constant v : unsigned(0 to 63)) return unsigned is
    variable e : unsigned(0 to 63);     -- 64
    variable a : unsigned(0 to 16*3-1); -- 48
    variable b : unsigned(0 to 8*4-1);  -- 32
    variable c : unsigned(0 to 4*5-1);  -- 20
    variable d : unsigned(0 to 2*6-1);  -- 12
  begin
    for i in 0 to 31 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));      end loop;
    for i in 0 to 15 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3));   end loop;
    for i in 0 to 7  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5));   end loop;
    for i in 0 to 3  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7));   end loop;
    for i in 0 to 1  loop d(i*6 to i*6+5):=clzi(5,c(i*10 to i*10+9)); end loop;
    return clzi(6,d(0 to 11));
  end function;
begin
  ~RESULT <= resize(clz64(~ARG[0]),~SIZE[~TYPO]);
end block;
-- clz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz#"
    , "type"      : "clz :: Word# -> Word#"
    , "templateD" :
"-- clz begin
clz~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz64 (constant v : unsigned(0 to 63)) return unsigned is
    variable e : unsigned(0 to 63);     -- 64
    variable a : unsigned(0 to 16*3-1); -- 48
    variable b : unsigned(0 to 8*4-1);  -- 32
    variable c : unsigned(0 to 4*5-1);  -- 20
    variable d : unsigned(0 to 2*6-1);  -- 12
  begin
    for i in 0 to 31 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));      end loop;
    for i in 0 to 15 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3));   end loop;
    for i in 0 to 7  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5));   end loop;
    for i in 0 to 3  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7));   end loop;
    for i in 0 to 1  loop d(i*6 to i*6+5):=clzi(5,c(i*10 to i*10+9)); end loop;
    return clzi(6,d(0 to 11));
  end function;
begin
  ~RESULT <= resize(clz64(~ARG[0]),~SIZE[~TYPO]);
end block;
-- clz end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz8#"
    , "type"      : "ctz8 :: Word# -> Word#"
    , "templateD" :
"-- ctz8 begin
ctz8~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz8 (constant v : unsigned(0 to 7)) return unsigned is
    variable e : unsigned(0 to 7);     -- 8
    variable a : unsigned(0 to 2*3-1); -- 6
  begin
    for i in 0 to 3 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 1 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    return clzi(3,a(0 to 5));
  end function;

  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  reverse_loop : for ~SYM[3] in ~SYM[1]'range generate
    ~SYM[2](~SYM[1]'high - ~SYM[3]) <= ~SYM[1](~SYM[3]);
  end generate;

  ~RESULT <= resize(clz8(~SYM[2](63 downto 56)),~SIZE[~TYPO]);
end block;
-- ctz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz16#"
    , "type"      : "ctz16 :: Word# -> Word#"
    , "templateD" :
"-- ctz16 begin
ctz16~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz16 (constant v : unsigned(0 to 15)) return unsigned is
    variable e : unsigned(0 to 15);    -- 16
    variable a : unsigned(0 to 4*3-1); -- 12
    variable b : unsigned(0 to 2*4-1); -- 8
  begin
    for i in 0 to 7 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 3 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    for i in 0 to 1 loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5)); end loop;
    return clzi(4,b(0 to 7));
  end function;

  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  reverse_loop : for ~SYM[3] in ~SYM[1]'range generate
    ~SYM[2](~SYM[1]'high - ~SYM[3]) <= ~SYM[1](~SYM[3]);
  end generate;

  ~RESULT <= resize(clz16(~SYM[2](63 downto 48)),~SIZE[~TYPO]);
end block;
-- ctz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz32#"
    , "type"      : "ctz32 :: Word# -> Word#"
    , "templateD" :
"-- ctz32 begin
ctz32~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz32 (constant v : unsigned(0 to 31)) return unsigned is
    variable e : unsigned(0 to 31);    -- 32
    variable a : unsigned(0 to 8*3-1); -- 24
    variable b : unsigned(0 to 4*4-1); -- 16
    variable c : unsigned(0 to 2*5-1); -- 10
  begin
    for i in 0 to 15 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));    end loop;
    for i in 0 to 7  loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3)); end loop;
    for i in 0 to 3  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5)); end loop;
    for i in 0 to 1  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7)); end loop;
    return clzi(5,c(0 to 9));
  end function;

  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  reverse_loop : for ~SYM[3] in ~SYM[1]'range generate
    ~SYM[2](~SYM[1]'high - ~SYM[3]) <= ~SYM[1](~SYM[3]);
  end generate;

  ~RESULT <= resize(clz32(~SYM[2](63 downto 32)),~SIZE[~TYPO]);
end block;
-- ctz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz64#"
    , "type"      : "ctz64 :: Word# -> Word#"
    , "templateD" :
"-- ctz64 begin
ctz64~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz64 (constant v : unsigned(0 to 63)) return unsigned is
    variable e : unsigned(0 to 63);     -- 64
    variable a : unsigned(0 to 16*3-1); -- 48
    variable b : unsigned(0 to 8*4-1);  -- 32
    variable c : unsigned(0 to 4*5-1);  -- 20
    variable d : unsigned(0 to 2*6-1);  -- 12
  begin
    for i in 0 to 31 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));      end loop;
    for i in 0 to 15 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3));   end loop;
    for i in 0 to 7  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5));   end loop;
    for i in 0 to 3  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7));   end loop;
    for i in 0 to 1  loop d(i*6 to i*6+5):=clzi(5,c(i*10 to i*10+9)); end loop;
    return clzi(6,d(0 to 11));
  end function;

  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  reverse_loop : for ~SYM[3] in ~SYM[1]'range generate
    ~SYM[2](~SYM[1]'high - ~SYM[3]) <= ~SYM[1](~SYM[3]);
  end generate;

  ~RESULT <= resize(clz64(~SYM[2]),~SIZE[~TYPO]);
end block;
-- ctz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz#"
    , "type"      : "ctz :: Word# -> Word#"
    , "templateD" :
"-- ctz begin
ctz~SYM[0] : block
  function enc(constant a : unsigned(1 downto 0)) return unsigned is
  begin
    case a is
      when \"00\" => return \"10\";
      when \"01\" => return \"01\";
      when \"10\" => return \"00\";
      when others => return \"00\";
    end case;
  end function;

  function clzi(
    constant n : in natural;
    constant i : in unsigned) return unsigned is
    variable v : unsigned(i'length-1 downto 0):=i;
  begin
    if v(n-1+n)='0' then
      return (v(n-1+n) and v(n-1)) & '0' & v(2*n-2 downto n);
    else
      return (v(n-1+n) and v(n-1)) & not v(n-1) & v(n-2 downto 0);
    end if;
  end function;

  function clz64 (constant v : unsigned(0 to 63)) return unsigned is
    variable e : unsigned(0 to 63);     -- 64
    variable a : unsigned(0 to 16*3-1); -- 48
    variable b : unsigned(0 to 8*4-1);  -- 32
    variable c : unsigned(0 to 4*5-1);  -- 20
    variable d : unsigned(0 to 2*6-1);  -- 12
  begin
    for i in 0 to 31 loop e(i*2 to i*2+1):=enc(v(i*2 to i*2+1));      end loop;
    for i in 0 to 15 loop a(i*3 to i*3+2):=clzi(2,e(i*4 to i*4+3));   end loop;
    for i in 0 to 7  loop b(i*4 to i*4+3):=clzi(3,a(i*6 to i*6+5));   end loop;
    for i in 0 to 3  loop c(i*5 to i*5+4):=clzi(4,b(i*8 to i*8+7));   end loop;
    for i in 0 to 1  loop d(i*6 to i*6+5):=clzi(5,c(i*10 to i*10+9)); end loop;
    return clzi(6,d(0 to 11));
  end function;

  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  reverse_loop : for ~SYM[3] in ~SYM[1]'range generate
    ~SYM[2](~SYM[1]'high - ~SYM[3]) <= ~SYM[1](~SYM[3]);
  end generate;

  ~RESULT <= resize(clz64(~SYM[2]),~SIZE[~TYPO]);
end block;
-- ctz end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap16#"
    , "type"      : "byteSwap16# :: Word# -> Word#"
    , "templateD" :
"-- byteSwap16 begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](63 downto 16) & ~SYM[1](7 downto 0) & ~SYM[1](15 downto 8);
end block;
-- byteSwap16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap32#"
    , "type"      : "byteSwap32# :: Word# -> Word#"
    , "templateD" :
"-- byteSwap32 begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](63 downto 32) & ~SYM[1](7  downto 0 ) & ~SYM[1](15 downto 8)
                                   & ~SYM[1](23 downto 16) & ~SYM[1](31 downto 24);
end block;
-- byteSwap32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap64#"
    , "type"      : "byteSwap64# :: Word# -> Word#"
    , "templateD" :
"-- byteSwap64 begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](7  downto 0 ) & ~SYM[1](15 downto 8)
           & ~SYM[1](23 downto 16) & ~SYM[1](31 downto 24)
           & ~SYM[1](39 downto 32) & ~SYM[1](47 downto 40)
           & ~SYM[1](55 downto 48) & ~SYM[1](63 downto 56);
end block;
-- byteSwap64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap#"
    , "type"      : "byteSwap# :: Word# -> Word#"
    , "templateD" :
"-- byteSwap begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](7  downto 0 ) & ~SYM[1](15 downto 8)
           & ~SYM[1](23 downto 16) & ~SYM[1](31 downto 24)
           & ~SYM[1](39 downto 32) & ~SYM[1](47 downto 40)
           & ~SYM[1](55 downto 48) & ~SYM[1](63 downto 56);
end block;
-- byteSwap end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Int#"
    , "type"      : "narrow8Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow8Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](7 downto 0),~SIZE[~TYPO]);
end block;
-- narrow8Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Int#"
    , "type"      : "narrow16Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow16Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](15 downto 0),~SIZE[~TYPO]);
end block;
-- narrow16Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Int#"
    , "type"      : "narrow32Int# :: Int# -> Int#"
    , "templateD" :
"-- narrow32Int begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](31 downto 0),~SIZE[~TYPO]);
end block;
-- narrow32Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Word#"
    , "type"      : "narrow8Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow8Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](7 downto 0),~SIZE[~TYPO]);
end block;
-- narrow8Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Word#"
    , "type"      : "narrow16Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow16Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](15 downto 0),~SIZE[~TYPO]);
end block;
-- narrow16Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Word#"
    , "type"      : "narrow32Word# :: Word# -> Word#"
    , "templateD" :
"-- narrow32Word begin
msb_~SYM[0] : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= resize(~SYM[1](31 downto 0),~SIZE[~TYPO]);
end block;
-- narrow32Word end"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.dataToTag#"
    , "primType" : "Function"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.tagToEnum#"
    , "primType" : "Function"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.unsafeCoerce#"
    , "type"      : "unsafeCoerce# :: a -> b"
    , "templateE" : "~ARG[0]"
    }
  }
]
