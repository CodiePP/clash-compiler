[ { "BlackBox" :
    { "name"      : "GHC.Prim.gtChar#"
     , "type"     : "gtChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] > ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geChar#"
    , "type"      : "geChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] >= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqChar#"
    , "type"      : "eqChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] == ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neChar#"
    , "type"      : "neChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] != ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltChar#"
    , "type"      : "ltChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] < ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leChar#"
    , "type"      : "leChar# :: Char# -> Char# -> Int#"
    , "templateE" : "(~ARG[0] <= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ord#"
    , "type"      : "ord :: Char# -> Int#"
    , "templateD" : "assign ~RESULT = $signed(~ARG[0]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.+#"
    , "type"      : "(+#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.-#"
    , "type"      : "(-#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.*#"
    , "type"      : "(*#) :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] * ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotInt#"
    , "type"      : "quotInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remInt#"
    , "type"      : "remInt# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] % ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemInt#"
    , "type"      : "quotRemInt# :: Int# -> Int# -> (#Int#, Int##)"
    , "templateD" :
"// quotRemInt begin
~SIGD[~SYM[0]][0];
~SIGD[~SYM[1]][0];
assign ~SYM[0] = ~ARG[0] / ~ARG[1];
assign ~SYM[1] = ~ARG[0] % ~ARG[1];

assign ~RESULT = {~SYM[0],~SYM[1]};
// quotRemInt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.andI#"
    , "type"      : "andI# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] & ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.orI#"
    , "type"      : "orI# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] | ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xorI#"
    , "type"      : "xorI# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] ^ ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.notI#"
    , "type"      : "notI# :: Int# -> Int#"
    , "templateE" : "~ ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.negateInt#"
    , "type"      : "negateInt# :: Int# -> Int#"
    , "templateE" : "-(~ARG[0])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>#"
     , "type"     : "(>#) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] > ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.>=#"
    , "type"      : "(>=#) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] >= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.==#"
    , "type"      : "(==) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] == ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim./=#"
    , "type"      : "(/=#) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] != ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<#"
    , "type"      : "(<#) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] < ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.<=#"
    , "type"      : "(<=#) :: Int# -> Int# -> Int#"
    , "templateE" : "(~ARG[0] <= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.chr#"
    , "type"      : "ord :: Int# -> Char#"
    , "templateD" : "assign ~RESULT = $unsigned(~ARG[0]);"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.int2Word#"
    , "type"      : "int2Word# :: Int# -> Word#"
    , "templateE" : "$unsigned(~ARG[0])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftL#"
    , "type"      : "uncheckedIShiftL# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] <<< ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRA#"
    , "type"      : "uncheckedIShiftRA# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] >>> ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftRL#"
    , "type"      : "uncheckedIShiftRL# :: Int# -> Int# -> Int#"
    , "templateE" : "~ARG[0] >> ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.plusWord#"
    , "type"      : "plusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] + ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.minusWord#"
    , "type"      : "minusWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] - ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.timesWord#"
    , "type"      : "timesWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] * ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotWord#"
    , "type"      : "quotWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] / ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.remWord#"
    , "type"      : "remWord# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] % ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemWord#"
    , "type"      : "quotRemWord# :: Word# -> Word# -> (#Word#, Word##)"
    , "templateD" :
"// quotRemWord begin
~SIGD[~SYM[0]][0];
~SIGD[~SYM[1]][0];
assign ~SYM[0] = ~ARG[0] / ~ARG[1];
assign ~SYM[1] = ~ARG[0] % ~ARG[1];

assign ~RESULT = {~SYM[0],~SYM[1]};
// quotRemWord end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.and#"
    , "type"      : "and# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] & ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.or#"
    , "type"      : "or# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] | ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.xor#"
    , "type"      : "xor# :: Word# -> Word# -> Word#"
    , "templateE" : "~ARG[0] ^ ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.not#"
    , "type"      : "not# :: Word# -> Word#"
    , "templateE" : "~ ~ARG[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedShiftL#"
    , "type"      : "uncheckedShiftL# :: Word# -> Int# -> Word#"
    , "templateE" : "~ARG[0] << ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.uncheckedIShiftL#"
    , "type"      : "uncheckedShiftRL# :: Word# -> Int# -> Word#"
    , "templateE" : "~ARG[0] >> ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.word2Int#"
    , "type"      : "int2Word# :: Word# -> Int#"
    , "templateE" : "$signed(~ARG[0])"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.gtWord#"
     , "type"     : "gtWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] > ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.geWord#"
    , "type"      : "geWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] >= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.eqWord#"
    , "type"      : "eqWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] == ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.neWord#"
    , "type"      : "neWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] != ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ltWord#"
    , "type"      : "ltWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] < ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.leWord#"
    , "type"      : "leWord# :: Word# -> Word# -> Int#"
    , "templateE" : "(~ARG[0] <= ~ARG[1]) ? ~SIZE[~TYPO]'sd1 : ~SIZE[~TYPO]'sd0"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt8#"
    , "type"      : "popCnt8# :: Word# -> Word#"
    , "templateD" :
"// popCnt8 begin
localparam width_~SYM[0] = 8;

// ceiling of log2
function integer log2_~SYM[1];
  input integer value;
  begin
    value = value-1;
    for (log2_~SYM[1]=0; value>0; log2_~SYM[1]=log2_~SYM[1]+1)
      value = value>>1;
  end
endfunction

// depth of the tree
localparam levels_~SYM[2] = log2_~SYM[1](width_~SYM[0]);

wire [levels_~SYM[2]:0] intermediate_~SYM[3] [0:(2*width_~SYM[0])-2];

// put input into the first half of the intermediate array
genvar i_~SYM[4];
~GENERATE
for (i_~SYM[4] = 0; i_~SYM[4] < width_~SYM[0]; i_~SYM[4]=i_~SYM[4]+1) begin : array_~SYM[5]
  assign intermediate_~SYM[3][i_~SYM[4]] = $unsigned(~ARG[0][i_~SYM[4]]);
end
~ENDGENERATE

// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer depth2Index_~SYM[5];
  input integer levels;
  input integer depth;

  depth2Index_~SYM[5] = (2 ** levels) - (2 ** depth);
endfunction

// Create the tree of instantiated components
genvar d_~SYM[6];
genvar i_~SYM[7];
~GENERATE
if (levels_~SYM[2] != 0) begin : make_tree_~SYM[8]
  for (d_~SYM[6] = (levels_~SYM[2] - 1); d_~SYM[6] >= 0; d_~SYM[6]=d_~SYM[6]-1) begin : tree_depth
    for (i_~SYM[7] = 0; i_~SYM[7] < (2**d_~SYM[6]); i_~SYM[7] = i_~SYM[7]+1) begin : tree_depth_loop
      assign intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+1)+i_~SYM[7]] =
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])] +
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(intermediate_~SYM[3][(2*width_~SYM[0])-2]);
// popCnt8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt16#"
    , "type"      : "popCnt16# :: Word# -> Word#"
    , "templateD" :
"// popCnt16 begin
localparam width_~SYM[0] = 16;

// ceiling of log2
function integer log2_~SYM[1];
  input integer value;
  begin
    value = value-1;
    for (log2_~SYM[1]=0; value>0; log2_~SYM[1]=log2_~SYM[1]+1)
      value = value>>1;
  end
endfunction

// depth of the tree
localparam levels_~SYM[2] = log2_~SYM[1](width_~SYM[0]);

logic [levels_~SYM[2]:0] intermediate_~SYM[3] [0:(2*width_~SYM[0])-2];

// put input into the first half of the intermediate array
genvar i_~SYM[4];
~GENERATE
for (i_~SYM[4] = 0; i_~SYM[4] < width_~SYM[0]; i_~SYM[4]=i_~SYM[4]+1) begin : array_~SYM[5]
  assign intermediate_~SYM[3][i_~SYM[4]] = $unsigned(~ARG[0][i_~SYM[4]]);
end
~ENDGENERATE

// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer depth2Index_~SYM[5];
  input integer levels;
  input integer depth;

  depth2Index_~SYM[5] = (2 ** levels) - (2 ** depth);
endfunction

// Create the tree of instantiated components
genvar d_~SYM[6];
genvar i_~SYM[7];
~GENERATE
if (levels_~SYM[2] != 0) begin : make_tree_~SYM[8]
  for (d_~SYM[6] = (levels_~SYM[2] - 1); d_~SYM[6] >= 0; d_~SYM[6]=d_~SYM[6]-1) begin : tree_depth
    for (i_~SYM[7] = 0; i_~SYM[7] < (2**d_~SYM[6]); i_~SYM[7] = i_~SYM[7]+1) begin : tree_depth_loop
      assign intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+1)+i_~SYM[7]] =
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])] +
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(intermediate_~SYM[3][(2*width_~SYM[0])-2]);
// popCnt16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt32#"
    , "type"      : "popCnt32# :: Word# -> Word#"
    , "templateD" :
"// popCnt32 begin
localparam width_~SYM[0] = 32;

// ceiling of log2
function integer log2_~SYM[1];
  input integer value;
  begin
    value = value-1;
    for (log2_~SYM[1]=0; value>0; log2_~SYM[1]=log2_~SYM[1]+1)
      value = value>>1;
  end
endfunction

// depth of the tree
localparam levels_~SYM[2] = log2_~SYM[1](width_~SYM[0]);

logic [levels_~SYM[2]:0] intermediate_~SYM[3] [0:(2*width_~SYM[0])-2];

// put input into the first half of the intermediate array
genvar i_~SYM[4];
~GENERATE
for (i_~SYM[4] = 0; i_~SYM[4] < width_~SYM[0]; i_~SYM[4]=i_~SYM[4]+1) begin : array_~SYM[5]
  assign intermediate_~SYM[3][i_~SYM[4]] = $unsigned(~ARG[0][i_~SYM[4]]);
end
~ENDGENERATE

// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer depth2Index_~SYM[5];
  input integer levels;
  input integer depth;

  depth2Index_~SYM[5] = (2 ** levels) - (2 ** depth);
endfunction

// Create the tree of instantiated components
genvar d_~SYM[6];
genvar i_~SYM[7];
~GENERATE
if (levels_~SYM[2] != 0) begin : make_tree_~SYM[8]
  for (d_~SYM[6] = (levels_~SYM[2] - 1); d_~SYM[6] >= 0; d_~SYM[6]=d_~SYM[6]-1) begin : tree_depth
    for (i_~SYM[7] = 0; i_~SYM[7] < (2**d_~SYM[6]); i_~SYM[7] = i_~SYM[7]+1) begin : tree_depth_loop
      assign intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+1)+i_~SYM[7]] =
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])] +
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(intermediate_~SYM[3][(2*width_~SYM[0])-2]);
// popCnt32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt64#"
    , "type"      : "popCnt64# :: Word# -> Word#"
    , "templateD" :
"// popCnt64 begin
localparam width_~SYM[0] = 64;

// ceiling of log2
function integer log2_~SYM[1];
  input integer value;
  begin
    value = value-1;
    for (log2_~SYM[1]=0; value>0; log2_~SYM[1]=log2_~SYM[1]+1)
      value = value>>1;
  end
endfunction

// depth of the tree
localparam levels_~SYM[2] = log2_~SYM[1](width_~SYM[0]);

logic [levels_~SYM[2]:0] intermediate_~SYM[3] [0:(2*width_~SYM[0])-2];

// put input into the first half of the intermediate array
genvar i_~SYM[4];
~GENERATE
for (i_~SYM[4] = 0; i_~SYM[4] < width_~SYM[0]; i_~SYM[4]=i_~SYM[4]+1) begin : array_~SYM[5]
  assign intermediate_~SYM[3][i_~SYM[4]] = $unsigned(~ARG[0][i_~SYM[4]]);
end
~ENDGENERATE

// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer depth2Index_~SYM[5];
  input integer levels;
  input integer depth;

  depth2Index_~SYM[5] = (2 ** levels) - (2 ** depth);
endfunction

// Create the tree of instantiated components
genvar d_~SYM[6];
genvar i_~SYM[7];
~GENERATE
if (levels_~SYM[2] != 0) begin : make_tree_~SYM[8]
  for (d_~SYM[6] = (levels_~SYM[2] - 1); d_~SYM[6] >= 0; d_~SYM[6]=d_~SYM[6]-1) begin : tree_depth
    for (i_~SYM[7] = 0; i_~SYM[7] < (2**d_~SYM[6]); i_~SYM[7] = i_~SYM[7]+1) begin : tree_depth_loop
      assign intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+1)+i_~SYM[7]] =
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])] +
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(intermediate_~SYM[3][(2*width_~SYM[0])-2]);
// popCnt64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt#"
    , "type"      : "popCnt8# :: Word# -> Word#"
    , "templateD" :
"// popCnt begin
localparam width_~SYM[0] = ~SIZE[~TYPO];

// ceiling of log2
function integer log2_~SYM[1];
  input integer value;
  begin
    value = value-1;
    for (log2_~SYM[1]=0; value>0; log2_~SYM[1]=log2_~SYM[1]+1)
      value = value>>1;
  end
endfunction

// depth of the tree
localparam levels_~SYM[2] = log2_~SYM[1](width_~SYM[0]);

logic [levels_~SYM[2]:0] intermediate_~SYM[3] [0:(2*width_~SYM[0])-2];

// put input into the first half of the intermediate array
genvar i_~SYM[4];
~GENERATE
for (i_~SYM[4] = 0; i_~SYM[4] < width_~SYM[0]; i_~SYM[4]=i_~SYM[4]+1) begin : array_~SYM[5]
  assign intermediate_~SYM[3][i_~SYM[4]] = $unsigned(~ARG[0][i_~SYM[4]]);
end
~ENDGENERATE

// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer depth2Index_~SYM[5];
  input integer levels;
  input integer depth;

  depth2Index_~SYM[5] = (2 ** levels) - (2 ** depth);
endfunction

// Create the tree of instantiated components
genvar d_~SYM[6];
genvar i_~SYM[7];
~GENERATE
if (levels_~SYM[2] != 0) begin : make_tree_~SYM[8]
  for (d_~SYM[6] = (levels_~SYM[2] - 1); d_~SYM[6] >= 0; d_~SYM[6]=d_~SYM[6]-1) begin : tree_depth
    for (i_~SYM[7] = 0; i_~SYM[7] < (2**d_~SYM[6]); i_~SYM[7] = i_~SYM[7]+1) begin : tree_depth_loop
      assign intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+1)+i_~SYM[7]] =
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])] +
             intermediate_~SYM[3][depth2Index_~SYM[5](levels_~SYM[2]+1,d_~SYM[6]+2)+(2*i_~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(intermediate_~SYM[3][(2*width_~SYM[0])-2]);
// popCnt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz8#"
    , "type"      : "clz8 :: Word# -> Word#"
    , "templateD" :
"// clz8 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:7] v;
assign v = ~ARG[0][7:0];

logic [0:7] e;
genvar i;
~GENERATE
for (i=0;i<4;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

logic [0:5] a;
genvar i1;
~GENERATE
for (i1=0;i1<2;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:3] res;
~GENERATE
if (1) begin
localparam n = 3;
logic [5:0] i;
assign i = a[0:5];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// clz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz16#"
    , "type"      : "clz16 :: Word# -> Word#"
    , "templateD" :
"// clz16 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:15] v;
assign v = ~ARG[0][15:0];

logic [0:15] e;
genvar i;
~GENERATE
for (i=0;i<8;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:11] a;
genvar i1;
~GENERATE
for (i1=0;i1<4;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:7] b;
genvar i2;
~GENERATE
for (i2=0;i2<2;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:4] res;
~GENERATE
if (1) begin
localparam n = 4;
logic [7:0] i;
assign i = b[0:7];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// clz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz32#"
    , "type"      : "clz32 :: Word# -> Word#"
    , "templateD" :
"// clz32 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:31] v;
assign v = ~ARG[0][31:0];

logic [0:31] e;
genvar i;
~GENERATE
for (i=0;i<16;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:23] a;
genvar i1;
~GENERATE
for (i1=0;i1<8;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:15] b;
genvar i2;
~GENERATE
for (i2=0;i2<4;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:9] c;
genvar i3;
~GENERATE
for (i3=0;i3<2;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:5] res;
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = c[0:9];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// clz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz64#"
    , "type"      : "clz64 :: Word# -> Word#"
    , "templateD" :
"// clz64 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:63] v;
assign v = ~ARG[0][63:0];

logic [0:63] e;
genvar i;
~GENERATE
for (i=0;i<32;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:47] a;
genvar i1;
~GENERATE
for (i1=0;i1<16;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:31] b;
genvar i2;
~GENERATE
for (i2=0;i2<8;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:19] c;
genvar i3;
~GENERATE
for (i3=0;i3<4;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:11] d;
genvar i4;
~GENERATE
for (i4=0;i4<2;i4=i4+1) begin : mux_stage4
  localparam n = 5;
  logic [9:0] i;
  assign i = c[i4*10:i4*10+9];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:6] res;
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = d[0:11];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// clz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz#"
    , "type"      : "clz :: Word# -> Word#"
    , "templateD" :
"// clz begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:63] v;
assign v = ~ARG[0][63:0];

logic [0:63] e;
genvar i;
~GENERATE
for (i=0;i<32;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:47] a;
genvar i1;
~GENERATE
for (i1=0;i1<16;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:31] b;
genvar i2;
~GENERATE
for (i2=0;i2<8;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:19] c;
genvar i3;
~GENERATE
for (i3=0;i3<4;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:11] d;
genvar i4;
~GENERATE
for (i4=0;i4<2;i4=i4+1) begin : mux_stage4
  localparam n = 5;
  logic [9:0] i;
  assign i = c[i4*10:i4*10+9];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:6] res;
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = d[0:11];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// clz end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz8#"
    , "type"      : "ctz8 :: Word# -> Word#"
    , "templateD" :
"// ctz8 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:7] v;
genvar k;
~GENERATE
for (k=0;k<8;k=k+1) begin : reverse
  assign v[k] = ~ARG[0][k];
end
~ENDGENERATE

logic [0:7] e;
genvar i;
~GENERATE
for (i=0;i<4;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:5] a;
genvar i1;
~GENERATE
for (i1=0;i1<2;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:3] res;
~GENERATE
if (1) begin
localparam n = 3;
logic [5:0] i;
assign i = a[0:5];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// ctz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz16#"
    , "type"      : "ctz16 :: Word# -> Word#"
    , "templateD" :
"// ctz16 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:15] v;
genvar k;
~GENERATE
for (k=0;k<16;k=k+1) begin : reverse
  assign v[k] = ~ARG[0][k];
end
~ENDGENERATE

logic [0:15] e;
genvar i;
~GENERATE
for (i=0;i<8;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:11] a;
genvar i1;
~GENERATE
for (i1=0;i1<4;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:7] b;
genvar i2;
~GENERATE
for (i2=0;i2<2;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:4] res;
~GENERATE
if (1) begin
localparam n = 4;
logic [7:0] i;
assign i = b[0:7];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// ctz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz32#"
    , "type"      : "ctz32 :: Word# -> Word#"
    , "templateD" :
"// ctz32 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:31] v;
genvar k;
~GENERATE
for (k=0;k<32;k=k+1) begin : reverse
  assign v[k] = ~ARG[0][k];
end
~ENDGENERATE

logic [0:31] e;
genvar i;
~GENERATE
for (i=0;i<16;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:23] a;
genvar i1;
~GENERATE
for (i1=0;i1<8;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:15] b;
genvar i2;
~GENERATE
for (i2=0;i2<4;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:9] c;
genvar i3;
~GENERATE
for (i3=0;i3<2;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:5] res;
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = c[0:9];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// ctz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz64#"
    , "type"      : "ctz64 :: Word# -> Word#"
    , "templateD" :
"// ctz64 begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:63] v;
genvar k;
~GENERATE
for (k=0;k<64;k=k+1) begin : reverse
  assign v[k] = ~ARG[0][k];
end
~ENDGENERATE

logic [0:63] e;
genvar i;
~GENERATE
for (i=0;i<32;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:47] a;
genvar i1;
~GENERATE
for (i1=0;i1<16;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:31] b;
genvar i2;
~GENERATE
for (i2=0;i2<8;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:19] c;
genvar i3;
~GENERATE
for (i3=0;i3<4;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:11] d;
genvar i4;
~GENERATE
for (i4=0;i4<2;i4=i4+1) begin : mux_stage4
  localparam n = 5;
  logic [9:0] i;
  assign i = c[i4*10:i4*10+9];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:6] res;
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = d[0:11];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// ctz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz#"
    , "type"      : "ctz :: Word# -> Word#"
    , "templateD" :
"// ctz begin
~GENERATE
if (1) begin
function [1:0] enc;
  input [1:0] a;
  case (a)
    2'b00:   enc = 2'b10;
    2'b01:   enc = 2'b01;
    2'b10:   enc = 2'b00;
    default: enc = 2'b00;
  endcase
endfunction

logic [0:63] v;
genvar k;
~GENERATE
for (k=0;k<64;k=k+1) begin : reverse
  assign v[k] = ~ARG[0][k];
end
~ENDGENERATE

logic [0:63] e;
genvar i;
~GENERATE
for (i=0;i<32;i=i+1) begin : enc_stage
  assign e[i*2:i*2+1] = enc(v[i*2:i*2+1]);
end
~ENDGENERATE

reg [0:47] a;
genvar i1;
~GENERATE
for (i1=0;i1<16;i1=i1+1) begin : mux_stage1
  localparam n = 2;
  logic [3:0] i;
  assign i = e[i1*4:i1*4+3];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : a[i1*3:i1*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:31] b;
genvar i2;
~GENERATE
for (i2=0;i2<8;i2=i2+1) begin : mux_stage2
  localparam n = 3;
  logic [5:0] i;
  assign i = a[i2*6:i2*6+5];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : b[i2*4:i2*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:19] c;
genvar i3;
~GENERATE
for (i3=0;i3<4;i3=i3+1) begin : mux_stage3
  localparam n = 4;
  logic [7:0] i;
  assign i = b[i3*8:i3*8+7];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : c[i3*5:i3*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:11] d;
genvar i4;
~GENERATE
for (i4=0;i4<2;i4=i4+1) begin : mux_stage4
  localparam n = 5;
  logic [9:0] i;
  assign i = c[i4*10:i4*10+9];
  always @(*) begin
    case (i[n-1+n])
      1'b0    : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : d[i4*6:i4*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

reg [0:6] res;
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = d[0:11];
always @(*) begin
  case (i[n-1+n])
    1'b0    : res = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : res = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(res);
end
~ENDGENERATE
// ctz end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap16#"
    , "type"      : "byteSwap16# :: Word# -> Word#"
    , "templateD" :
"// byteSwap16 begin
~SIGDO[~SYM[0]];
assign ~SYM[0] = ~ARG[0];
assign ~RESULT = {~SYM[0][63:16],~SYM[0][7:0],~SYM[0][15:8]};
// byteSwap16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap32#"
    , "type"      : "byteSwap32# :: Word# -> Word#"
    , "templateD" :
"// byteSwap32 begin
~SIGDO[~SYM[0]];
assign ~SYM[0] = ~ARG[0];
assign ~RESULT = {~SYM[0][63:32],~SYM[0][7:0],~SYM[0][15:8],~SYM[0][23:16],~SYM[0][31:24]};
// byteSwap32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap64#"
    , "type"      : "byteSwap64# :: Word# -> Word#"
    , "templateD" :
"// byteSwap64 begin
~SIGDO[~SYM[1]];
assign ~SYM[1] = ~ARG[0];
assign ~RESULT = {~SYM[1][7:0],~SYM[1][15:8],~SYM[1][23:16],~SYM[1][31:24]
                 ,~SYM[1][39:32],~SYM[1][47:40],~SYM[1][55:48],~SYM[1][63:56]};
// byteSwap64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.byteSwap#"
    , "type"      : "byteSwap# :: Word# -> Word#"
    , "templateD" :
"// byteSwap begin
~SIGDO[~SYM[1]];
assign ~SYM[1] = ~ARG[0];
assign ~RESULT = {~SYM[1][7:0],~SYM[1][15:8],~SYM[1][23:16],~SYM[1][31:24]
                 ,~SYM[1][39:32],~SYM[1][47:40],~SYM[1][55:48],~SYM[1][63:56]};
// byteSwap end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Int#"
    , "type"      : "narrow8Int# :: Int# -> Int#"
    , "templateD" :
"// narrow8Int begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $signed(~SYM[0][7:0]);
// narrow8Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Int#"
    , "type"      : "narrow16Int# :: Int# -> Int#"
    , "templateD" :
"// narrow16Int begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $signed(~SYM[0][15:0]);
// narrow16Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Int#"
    , "type"      : "narrow32Int# :: Int# -> Int#"
    , "templateD" :
"// narrow32Int begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $signed(~SYM[0][31:0]);
// narrow32Int end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow8Word#"
    , "type"      : "narrow8Int# :: Word# -> Word#"
    , "templateD" :
"// narrow8Word begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $unsigned(~SYM[0][7:0]);
// narrow8Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow16Word#"
    , "type"      : "narrow16Word# :: Word# -> Word#"
    , "templateD" :
"// narrow16Word begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $unsigned(~SYM[0][15:0]);
// narrow16Word end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.narrow32Word#"
    , "type"      : "narrow32Int# :: Word# -> Word#"
    , "templateD" :
"// narrow32Word begin
~SIGD[~SYM[0]][0];
assign ~SYM[0] = ~ARG[0];

assign ~RESULT = $unsigned(~SYM[0][31:0]);
// narrow32Word end"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.dataToTag#"
    , "primType" : "Function"
    }
  }
, { "Primitive" :
    { "name"     : "GHC.Prim.tagToEnum#"
    , "primType" : "Function"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.unsafeCoerce#"
    , "type"      : "unsafeCoerce# :: a -> b"
    , "templateE" : "~ARG[0]"
    }
  }
]
